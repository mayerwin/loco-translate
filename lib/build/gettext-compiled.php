<?php
/**
 * Compiled source code - DO NOT EDIT!
 * @author Tim Whitlock http://timwhitlock.info/
 * @date Fri, 06 Dec 2013 14:23:15 +0000 
 */
   class LocoArray implements Iterator { private $i; private $length; private $keys; private $vals; private $index; public function __construct( array $data = array() ){ $this->keys = array_keys( $data ); $this->vals = array_values( $data ); $this->index = array_flip( array_map( 'strtolower', $this->keys ) ); $this->length = count( $this->keys ); $this->rewind(); } public function add( $key, $val ){ $k = strtolower($key); if( isset($this->index[$k]) ){ $this->keys[ $this->index[$k] ] = $key; $this->vals[ $this->index[$k] ] = $val; } else { $this->index[$k] = $this->length++; $this->keys[] = $key; $this->vals[] = $val; } return $this; } public function to_array(){ return array_combine( $this->keys, $this->vals ); } public function count(){ return $this->length; } public function trimmed( $prop ){ return trim( $this->__get($prop) ); } public function has( $key ){ return isset( $this->index[ strtolower($key) ] ); } public function __get( $key ){ $key = strtolower( $key ); return isset($this->index[$key]) ? $this->vals[ $this->index[$key] ] : null; } public function rewind(){ $this->i = reset( $this->index ); } public function key(){ return is_int($this->i) ? $this->keys[$this->i] : null; } public function current(){ return is_int($this->i) ? $this->vals[$this->i] : null; } public function valid(){ return is_int($this->i); } public function next(){ $this->i = next( $this->index ); } } function loco_parse_po( $src ){ $i = -1; $key = ''; $entries = array(); $template = array( '#' => array(), 'id' => array(), 'str' => array(), 'ctxt' => array() ); foreach( preg_split('/[\r\n]+/', $src) as $line ){ while( $line = trim($line) ){ $c = $line{0}; if( '"' === $c ){ if( $key && isset($entry) ){ $entry[$key][$idx][] = loco_po_unquote( $line ); } } else if( '#' === $c ){ if( isset($entry['i']) ){ unset( $entry ); $entry = $template; } $f = empty($line{1}) ? ' ' : $line{1}; $entry['#'][$f][] = trim( substr( $line, 1+strlen($f) ), "/ \n\r\t" ); } else if( preg_match('/^msg(id|str|ctxt|id_plural)(?:\[(\d+)\])?[ \t]+/', $line, $r ) ){ $key = $r[1]; $idx = isset($r[2]) ? (int) $r[2] : 0; if( 'str' === $key ){ if( ! isset($entry['i']) ){ $entry['i'] = ++$i; $entries[$i] = &$entry; } } else if( ! isset($entry) || isset($entry['i']) ){ unset( $entry ); $entry = $template; } $line = substr( $line, strlen($r[0]) ); continue; } continue 2; } } unset( $entry ); $assets = array(); foreach( $entries as $i => $entry ){ $asset = array ( 'id' => '', 'source' => implode('',$entry['id'][0]), 'target' => implode('',$entry['str'][0]), ); if( isset($entry['ctxt'][0]) ){ $asset['context'] = implode('',$entry['ctxt'][0]); } $comments = array(); isset($entry['#'][' ']) and $comments = array_merge( $comments, $entry['#'][' ']); isset($entry['#']['.']) and $comments = array_merge( $comments, $entry['#']['.']); $comments and $asset['comment'] = implode("\n", $comments); if( isset($entry['#'][':']) ){ $asset['refs'] = implode( "\n", $entry['#'][':'] ); } if( isset($entry['#'][',']) ){ foreach( $entry['#'][','] as $flag ){ if( $flag = loco_po_parse_flag($flag) ){ $asset['flag'] = $flag; break; } } } $pidx = count($assets); $assets[] = $asset; if( isset($entry['id_plural']) || isset($entry['str'][1]) ){ $idx = 0; $num = max( 2, count($entry['str']) ); while( ++$idx < $num ){ $assets[] = array ( 'id' => '', 'parent' => $pidx, 'plural' => $idx, 'source' => isset($entry['id_plural'][0]) ? implode('',$entry['id_plural'][0]) : '', 'target' => isset($entry['str'][$idx]) ? implode('',$entry['str'][$idx]) : '', ); } } } return $assets; } function loco_po_parse_flag( $text, $flag = 0 ){ static $map; if( ! isset($map) ){ $map = unserialize('a:1:{i:4;s:8:"#, fuzzy";}'); } foreach( explode(',',$text) as $needle ){ if( $needle = trim($needle) ){ foreach( $map as $loco_flag => $haystack ){ if( false !== stripos($haystack, $needle) ){ $flag |= $loco_flag; break; } } } } return $flag; } function loco_po_unquote( $str ){ return substr( stripcslashes($str), 1, -1 ); } function loco_parse_po_headers( $str ){ $headers = new LocoArray( array() ); foreach( explode("\n",$str) as $line ){ $i = strpos($line,':') and $key = trim( substr($line,0,$i) ) and $headers->add( $key, trim( substr($line,++$i) ) ); } return $headers; }  define( 'LOCO_FLAG_OK', 0 ); define( 'LOCO_FLAG_ERROR', 1 ); define( 'LOCO_FLAG_REVIEW', 2 ); define( 'LOCO_FLAG_PENDING', 3 ); define( 'LOCO_FLAG_FUZZY', 4 ); function loco_flags(){ static $flags = array ( LOCO_FLAG_OK => 'Translated', LOCO_FLAG_ERROR => 'Incorrect', LOCO_FLAG_REVIEW => 'Needs review', LOCO_FLAG_PENDING => 'Pending sign-off', LOCO_FLAG_FUZZY => 'Fuzzy', ); return $flags; } function loco_flag( $f ){ $flags = loco_flags(); if( ! isset($flags[$f]) ){ throw new Exception('Invalid LOCO_FLAG_ constant ', var_export($f,1) ); } return $flags[$f]; }   final class PHPTokens implements Iterator { private $tokens; private $i; private $skip_tokens = array(); private $skip_strings = array(); public function __construct( array $tokens ){ $this->tokens = $tokens; $this->rewind(); } public function ignore(){ foreach( func_get_args() as $t ){ if( is_int($t) ){ $this->skip_tokens[$t] = true; } else { $this->skip_strings[$t] = true; } } return $this; } public function advance(){ $this->next(); return $this->current(); } public function rewind(){ $this->i = false === reset($this->tokens) ? null : key($this->tokens); } public function valid(){ return isset($this->i); } public function key(){ return $this->i; } public function next(){ $this->i = false === next($this->tokens) ? null : key($this->tokens); } public function current(){ while( isset($this->i) ){ $tok = $this->tokens[$this->i]; if( is_array($tok) ){ if( isset($this->skip_tokens[$tok[0]]) ){ $this->next(); } else { return $tok; } } else if( isset($this->skip_strings[$tok]) ){ $this->next(); } else { return $tok; } } return false; } }  function loco_parse_comment($comment){ if( '*' === $comment{1} ){ $lines = array(); foreach( explode("\n", $comment) as $line ){ $line and $lines[] = trim($line,"/* \r\t"); } $comment = implode("\n", $lines); } return trim( $comment,"/ \n\r\t" ); }  function decapse_string( $s ){ if( empty($s) ){ return ''; } $q = $s{0}; switch( $q ){ case "'": case '"': $s = substr( $s, 1, -1 ); if( '"' === $q ){ return stripcslashes($s); } return str_replace( array( '\\'.$q, '\\\\' ), array( $q, '\\' ), $s ); default: trigger_error( "Bad quote character ($q) at offset 0", E_USER_NOTICE ); return $s; } } function loco_extract_php( array $tokens, $fileref = '' ){ $extractor = new LocoPHPExtractor; return $extractor->extract( $tokens, $fileref ); } final class LocoPHPExtractor { private static $rules = array ( '_' => 's', 'gettext' => 's', 'dgettext' => '_s', 'ngettext' => 'sp', 'dngettext' => '_sp', '__' => 's', '_e' => 's', '_c' => 's', '_n' => 'sp', '_n_noop' => 'sp', '_nc' => 'sp', '__ngettext' => 'sp', '__ngettext_noop' => 'sp', '_x' => 'sc', '_ex' => 'sc', '_nx' => 'sp_c', '_nx_noop' => 'spc', '_n_js' => 'sp', '_nx_js' => 'spc', 'esc_attr__' => 's', 'esc_html__' => 's', 'esc_attr_e' => 's', 'esc_html_e' => 's', 'esc_attr_x' => 'sc', 'esc_html_x' => 'sc', 'comments_number_link' => '_sp', 't' => 's', 'st' => 's', 'trans' => 's', 'transChoice' => 'sp', ); private $exp = array(); private $reg = array(); public function extract( array $tokens, $fileref = '' ){ $tokens = new PHPTokens( $tokens ); $tokens->ignore( T_WHITESPACE ); $comment = ''; foreach( $tokens as $tok ){ if( isset($args) ){ if( ')' === $tok ){ isset($arg) and $arg and $args[] = $arg; $this->push( $rule, $args, $comment, $ref ); unset($args,$arg); $comment = ''; } else if( ',' === $tok ){ isset($arg) and $arg and $args[] = $arg; unset($arg); } else if( isset($arg) ){ $arg[] = $tok; } else { $arg = array( $tok ); } } else if( is_array($tok) ){ list($t,$s) = $tok; if( T_COMMENT === $t || T_DOC_COMMENT === $t ){ $comment = $s; } else if( T_STRING === $t && isset(self::$rules[$s]) && '(' === $tokens->advance() ){ $rule = self::$rules[$s]; $args = array(); $ref = $fileref ? $fileref.':'.$tok[2]: ''; } else if( $comment && false === stripos($comment, 'translators') ){ $comment = ''; } } } return $this->exp; } private function push( $rule, array $args, $comment = '', $ref = '' ){ $s = strpos( $rule, 's'); $p = strpos( $rule, 'p'); $c = strpos( $rule, 'c'); foreach( $args as $i => $tokens ){ if( 1 === count($tokens) && is_array($tokens[0]) && T_CONSTANT_ENCAPSED_STRING === $tokens[0][0] ){ $args[$i] = decapse_string( $tokens[0][1] ); } else { $args[$i] = null; } } $key = $msgid = $args[$s]; if( ! $msgid ){ return null; } $entry = array ( 'id' => '', 'source' => $msgid, 'target' => '', ); if( $c && isset($args[$c]) ){ $entry['context'] = $args[$c]; $key .= "\0". $args[$c]; } if( $ref ){ $entry['refs'] = $ref; } if( $comment ){ $entry['comment'] = loco_parse_comment($comment); } if( isset($this->reg[$key]) ){ $index = $this->reg[$key]; $a = array(); isset($this->exp[$index]['refs']) and $a[] = $this->exp[$index]['refs']; isset($entry['refs']) and $a[] = $entry['refs']; $a && $this->exp[$index]['refs'] = implode(" ", $a ); $a = array(); isset($this->exp[$index]['comment']) and $a[] = $this->exp[$index]['comment']; isset($entry['comment']) and $a[] = $entry['comment']; $a && $this->exp[$index]['comment'] = implode("\n", $a ); } else { $index = count($this->exp); $this->reg[$key] = $index; $this->exp[] = $entry; } if( $p && isset($args[$p]) ){ $msgid_plural = $args[$p]; $entry = array ( 'id' => '', 'source' => $msgid_plural, 'target' => '', 'plural' => 1, 'parent' => $index, ); $key = $msgid_plural."\0\0"; if( isset($this->reg[$key]) ){ $plural_index = $this->reg[$key]; $this->exp[$plural_index] = $entry; } else { $plural_index = count($this->exp); $this->reg[$key] = $plural_index; $this->exp[] = $entry; } } return $index; } public function get_xgettext( $input = '-' ){ $cmd = defined('WHICH_XGETTEXT') ? WHICH_XGETTEXT : 'xgettext'; $cmd.= ' -LPHP -c -o-'; if( $k = $this->get_xgettext_keywords() ){ $cmd.= ' -k'.implode(' -k', $k ); } return $cmd.' '.$input; } public function get_xgettext_keywords(){ $ks = array(); foreach( self::$rules as $word => $rule ){ $s = strpos( $rule, 's'); $k = $word.':'.++$s; if( false !== $p = strpos( $rule, 'p') ){ $k.= ','.++$p; } if( false !== $p = strpos( $rule, 'c') ){ $k.= ','.++$p.'c'; } $ks[] = $k; } return $ks; } }   function loco_compile_mo( $po ){ $descriptorspec = array( 0 => array('pipe', 'r'), 1 => array('pipe', 'w'), 2 => array('pipe', 'a'), ); $cmd = WHICH_MSGFMT.' -o - -'; $process = proc_open($cmd, $descriptorspec, $pipes ); if( ! $process ){ throw new Exception('Failed to open process to '.$cmd); } fwrite($pipes[0], $po); fclose($pipes[0]); $err = stream_get_contents($pipes[2]); fclose($pipes[2]); $mo = stream_get_contents($pipes[1]); fclose($pipes[1]); $e = proc_close($process); if( 0 !== $e ){ $err and trigger_error( $err, E_USER_WARNING ); throw new Exception('Gettext msgfmt exited with code '.sprintf('%d',$e).'; Got '.strlen($mo).' bytes from '.strlen($po).' bytes'); } return $mo; } function loco_compile_mo_file( $source ){ $descriptorspec = array ( 0 => array('pipe', 'r'), 1 => array('pipe', 'w'), 2 => array('pipe', 'a'), ); $dest = $source.'.mo'; $cmd = WHICH_MSGFMT.' -o '.escapeshellarg($dest).' '.escapeshellarg($source); $process = proc_open($cmd, $descriptorspec, $pipes ); if( ! $process ){ throw new Exception('Failed to open process to '.$cmd); } $err = stream_get_contents($pipes[0]); fclose($pipes[0]); $e = proc_close($process); if( 0 !== $e ){ $err and trigger_error( $err, E_USER_WARNING ); throw new Exception('Gettext msgfmt exited with code '.sprintf('%d',$e).';'); } return $dest; }  function loco_relative_path( $source_path, $target_path ){ $rel = ''; $common = false; $src = preg_split('!/+!', $source_path, -1, PREG_SPLIT_NO_EMPTY ); $dst = preg_split('!/+!', $target_path, -1, PREG_SPLIT_NO_EMPTY ); while( $src && $dst ){ if( current($src) !== current($dst) ){ break; } $common = true; array_shift($src); array_shift($dst); } if( ! $common ){ return $target_path; } if( $src ){ $up = array_fill( 0, count($src), '..' ); $rel = implode('/', $up ); } if( $dst ){ $rel && $rel .= '/'; $rel .= implode('/', $dst ); } return $rel; } function loco_po_stats( array $po ){ $t = $n = $f = $u = 0; foreach( $po as $r ){ if( ! isset($r['source']) || '' === $r['source'] ){ continue; } if( isset($r['parent']) && is_int($r['parent']) ){ continue; } $t++; if( '' === $r['target'] ){ $u++; } else if( isset($r['flag']) && LOCO_FLAG_FUZZY === $r['flag'] ){ $f++; } else { $n++; } } $r = $t && $n ? $n / $t : 0; $p = (string) round( $r * 100 ); return compact('t','p','f','u'); } 